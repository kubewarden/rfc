|              |                                                  |
| :----------- | :----------------------------------------------- |
| Feature Name | Certificate Handling                             |
| Start Date   | Aug 11 2023                                      |
| Update Date  | 2024/09/05                                       |
| Category     | enhancement, feature                             |
| RFC PR       | [#24](https://github.com/kubewarden/rfc/pull/24) |
| State        | **ACCEPTED**                                     |

# Summary

[summary]: #summary

The goal of this RFC is to summarize the usage of certificates inside of the
Kubewarden stack and come up with a proposal about how to manage them without
having to resort to external dependencies like CertManager.

# Motivation

The first goal of this RFC is to provide a picture of the current state of
certificate handling in Kubewarden. How many certificates are used, by
which components, which CA signed them and how have they been generated.

The second goal is to come up with an architecture that removes the external
dependency against CertManager. The new solution should also take into account
certificate rotation.

## Examples / User Stories

> As a Kubernetes operator, I don't want to install CertManager
> in order to deploy Kubewarden.

> As a Kubernetes operator,
> I want Kubewarden certificates to be automatically rotated
> before they reach their expiration date.

# Detailed design

Let's start by describing the current state of certificate handling in
Kubewarden. After that, we will propose a new design that removes the dependency
against CertManager.

## Components that make use of TLS certificates

All the certificates used by the Kubewarden stack are internal to the cluster.
All of them are used to secure the communication between the API Server and
different HTTPS endpoints.

These are the HTTP servers managed by Kubewarden that require TLS termination:

- kubewarden-controller: this is a Validating and Mutating webhook endpoint
  that processes the Kubewarden CRDs (like `PolicyServer`,
  `ClusterAdmissionPolicy` and `AdmissionPolicy`)
- Policy Server: each Deployment has its own dedicated certificate

> **Note:** all these endpoints are either Validating or Mutating webhook
> endpoints for Kubernetes

Currently, in Kubewarden 1.16, the certificate used by the
`kubewarden-controller` is generated by CertManager. On the other hand, the
certificates used by the Policy Server instances are generated by our
controller.

The `kubewarden-controller` generates a self-signed Certificate Authority (CA)
that is then used to sign all the Policy Server certificates.

## Webhook Configuration and Certificates

Both `ValidatingWebhookConfiguration` and `MutatingWebhookConfiguration`
resources have a
[`clientConfig`](https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.27/#webhookclientconfig-v1-admissionregistration-k8s-io)
object in their definition. The `clientConfig.caBundle` has the bundle
of CAs required to verify the TLS termination of the webhook endpoint:

```yaml
apiVersion: admissionregistration.k8s.io/v1
kind: MutatingWebhookConfiguration
webhooks:
  - name: my-webhook.example.com
    clientConfig:
      caBundle: <CA_BUNDLE>
      service:
        namespace: my-service-namespace
        name: my-service-name
        path: /my-path
        port: 1234
```

We have one `MutatingWebhookConfiguration` resource used by the
`kubewarden-controller` which holds a reference to the CA managed by
CertManager.

Each `ClusterAdmissionPolicy` and `AdmissionPolicy` has a dedicated
`(Validating|Mutating)WebhookConfiguration` object defined. For all of them,
the `clientConfig.caBundle` contains the certificate of the CA generated by our
controller.

## Proposed Design

We would like to get rid of CertManager. To do that we need to change how
certificates are managed for the `kubewarden-controller`. Going forward, the
Helm chart installation and  the controller will take care of bootstrapping the
certificates, while the `kubewarden-controller` will rotate them when they are about to expire.

## Possible Scenarios

This section aims to cover the different scenarios. For each one of them we
start by defining an event and then we outline the different actions that have
to be done.

### Kubewarden Fresh Install

The Kubewarden stack has just been installed. The following actions have to be
done:

- Helm chart generates Certificate Authority(CA) and stores it in a secret
- Helm chart generates a certificate for the `kubewarden-controller` webhooks,
  signs it with the CA, and stores it in a secret
- Helm chart uses the CA in the `caBundle` configuration in webhooks to
  validate CRDs pointing to the `kubewarden-controller`
- Start the Kubewarden controller webhooks HTTPS server using this certificate.
  The certificate is mounted inside of the Pod

### New Policy Server Defined

A new `PolicyServer` is defined, the following actions have to be done:

- Generate new certificate, sign it with our CA
- Create Policy Server Deployment with the secret containing the certificate
  configured to be mounted in the pod.

It's important to note that the CA used to sign the Policy Server certificate
is the same CA used to sign the `kubewarden-controller` certificate. It's not
the internal CA generated to sign Policy Server certificates as was done
before.

### New
`AdmissionPolicy`/`ClusterAdmissionPolicy`/`ClusterAdmissionPolicyGroup`/`AdmissionPolicyGroup`
is defined

A new policy is defined inside the cluster, ensure the following actions are
done:

- Register the webhook against the Kubernetes API, use our CA in
  `clientConfig.caBundle`

> **Note:** it doesn't matter which Policy Server is going to host the policy.
> All the Policy Server instances use a certificate that is signed by our CA.
> Hence we always put our CA in the `clientConfig.caBundle`.

### Policy Server and `kubewarden-controller` Certificates Renewed

From time to time we need to renew the certificate issued to the
`kubewarden-controller` and a Policy Server instance. The main reason to
perform this operation is to ensure the certificates in use do not expire.

To renew a certificate the following actions are needed:

- Generate new certificate, sign it with our CA
- Update the secret storing the certificate
- Kubernetes automatically updates the certificate secret that is mounted
  within the Pods running the Policy Server or the `kubewarden-controller`.
  Both of these processes will detect the updated certificate file they
  accessed during startup and will refresh their TLS configuration accordingly.

> **Note:** there's no need to restart the Pods. Since Kubewarden v1.16, Policy
> Server and `kubewarden-controller` are able to detect changes in the
> certificate file and reload it at runtime. Also, there's no need to touch the
> webhook configuration objects related to the policies hosted by the Policy
> Server. The new certificate is still signed by the same CA, hence nothing has
> to be changed.

### Internal CA changes

The internal CA managed by Kubewarden might be recreated (for example, to avoid
its expiration). This is the most disruptive event that can happen, especially
once some policies are deployed.

The following actions have to be performed to renew the internal CA:

- Generates a new CA certificate
- Updates the secret storing the CA certificate with the new CA and the old CA
- Generate a new CA bundle that contains the previous internal CA and the new
  one
- For each webhook configuration managed by Kubewarden (meaning all the
  policies deployed, plus the `kubewarden-controller`):
  - Update the `clientConfig.caBundle`: ensure it contains the CA bundle
    created during the previous step
- For each `PolicyServer` defined:
  - Generate a new certificate, sign it with the new CA
  - Update the secret storing the policy server certificate
- For the `kubewarden-controller`:
  - Generate a new certificate, sign it with the new CA
  - Update the secret storing the controller certificate

All certificates generated uses the ECDSA P-256 curve algorithm for the keys.

The root CA rotation is initiated 60 days before the expiration date. This
gives plenty of time to ensure all the Policy Server instances and the
`kubewarden-controller` pods are using a certificate that has been issued by
the new root CA. 

Once the old CA is invalid:
- Remove the old root CA from the CA bundle
- For each webhook configuration managed by Kubewarden (meaning all the
  policies deployed, plus the validating and mutating webhooks defined by the
  Kubewarden Controller):
  - Update the `clientConfig.caBundle`: use the freshly computed bundle
  
> **Note:** there's no need to restart the Policy Server/kubewarden-controller
> pods. By that time (60 days passed since the new root CA and their
> certificates were recreated), they are all using a certificate issued by the
> new root CA.

## Controller Bootstrap

Helm chart installation is responsible to create the first root CA. The root CA
is used to sign the first certificate user by the `kubewarden-controller`. The
root CA is also used in the `clientConfig.caBundle` of the webhooks used to
validate the CRDs. The root CA has a validity of 10 years and the certificate
used by the controller has a validity of 1 year. Both use the ECDSA P-256
curve  algorithm for the keys. 

## Reconciliation Loops

This section describes how the `kubewarden-controller` reconciliation loops
should be arranged. We can split the changes in three different parts: 

- Policy Server reconciliation loop changes
- Policy types reconciliation loop changes
- New certificates reconciliation loop

The new reconciliation loop has to be added to the `kubewarden-controller` to
reconcile the certificates used by the whole Kubewarden stack.

### Certificates Reconciliation Loop

The new added reconciliation loop should check the expiration date of all the
certificates used by the Kubewarden stack. Actually, this reconciliation loop
is a runnable added to the controller manager. The runnable starts a ticker
that verifies validity of the certificates every 12 hours. 

If during the reconciliation loop the root CA is about to expire, that is, 
the certificate will expire in less than 60 days, the
reconciliation loop should generate a new root CA, update the secret storing
the root CA and update the `clientConfig.caBundle` of all the webhook
configurations. Then it should generate a new certificate for the
`kubewarden-controller` and all the policy servers deployed in the cluster.

Also during the reconciliation, if a certificate used by a Policy Server or the
`kubewarden-controller` is about to expire, the reconciliation loop should
generate a new certificate, sign it with the root CA and update the secret
storing the certificate. There is no need to update the webhook configurations,
since the CA is the same.

If the old CA stored in the secret with the current CA in use is
invalid, the reconciliation loop should update the secret, removing the old CA.
Then it should update the `clientConfig.caBundle` of all webhook configurations
to contain only the new CA.

### Policy Server

The reconciliation loop should be updated to remove the internal CA generation
used only to sign the Policy Server certificates. The reconciliation loop
should use the same root CA used by the `kubewarden-controller` to sign the
Policy Server certificates.

### Policy Types 

The reconciliation loops that handle the `ClusterAdmissionPolicy`,
`AdmissionPolicy`, `ClusterAdmissionPolicyGroup` and `AdmissionPolicyGroup`
should also use the root CA generated by the `kubewarden-controller` to configure
the `clientConfig.caBundle` of the webhooks.

# Drawbacks

[drawbacks]: #drawbacks

# Alternatives

[alternatives]: #alternatives

See this RFC file history. The initial version of the document has a different proposal.

# Unresolved questions

[unresolved]: #unresolved-questions

None
